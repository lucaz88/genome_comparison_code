#!!! this code requires 2 input files: 'fun_profi' and 'ITs_mapping'
#!!! both are generated by the ATLAS_annotation.R code

install.packages("BiocManager")
BiocManager::install(c("snpStats", "apcluster"))

fun_profi = readRDS()
ITs_mapping = readRDS()



##### Create Linked Trait CLusters (LTCs) ------------------------------------------------------

### compute Linkage disequilibrium
library(snpStats)
fun_profi_fix = as.matrix(fun_profi)+1 # presence is 2 and absence is 1
fun_profi_fix = rbind(fun_profi_fix, rep(1, ncol(fun_profi_fix)))
fun_profi_fix = apply(fun_profi_fix, 2, as.raw) # not necessary

trait_cor = ld(new("SnpMatrix", fun_profi_fix), depth = ncol(fun_profi_fix)-1,
               stats="R.squared", symmetric = T) # D.prime R.squared
# image(trait_cor)
trait_cor <- as(trait_cor, "matrix")
diag(trait_cor) <- 1



### filter out noise
mtf = 0.03 # Minimum trait frequency
good_traits = colnames(fun_profi)[colSums(fun_profi)/nrow(fun_profi) > mtf]
good_traits = good_traits[!good_traits %in% colnames(trait_cor)[colSums(is.na(trait_cor)) > 0]]

fun_profi_filt <- fun_profi[, good_traits] # remove super rare traits
ITs_mapping_filt <- ITs_mapping[match(good_traits, ITs_mapping$col_lab), ]
trait_cor_filt = trait_cor[good_traits, good_traits]



### cluster traits in LTCs
library(dynamicTreeCut)
trait_dist_filt <- as.dist(1-trait_cor_filt)
trait_hc_filt <- hclust(as.dist(trait_dist_filt), "ward.D2")

minModuleSize = 3 # quite important for the quality of the clustering!!!
trait_cl = cutreeDynamic(dendro = trait_hc_filt, minClusterSize=minModuleSize, #cutHeight=1,
                         method="hybrid", distM = as.matrix(trait_dist_filt), deepSplit = 4)
trait_cl[trait_cl == 0] <- "uncl."
#!!! manually remove poorly clustered traits from core LTC 2 & 3, see 'manual_edit_LTCs.odp'
trait_cl[trait_hc_filt$labels %in% c("M00793","bacteriocin","M00086","M00004","M00006","M00026","M00320")] <- "uncl."
#---
trait_cl_col <- DescTools::ColToGray(qualpalr::qualpal(n = length(unique(trait_cl)), "rainbow")$hex) #!! gray-scale
# trait_cl_col <- qualpalr::qualpal(n = length(unique(trait_cl)), "rainbow")$hex #!! colors
trait_cl_col <- trait_cl_col[match(trait_cl, unique(trait_cl))]
trait_cl_col[grepl("uncl.", trait_cl)] <- "white"
hist(table(trait_cl[!grepl("uncl.", trait_cl)]), breaks = max(table(trait_cl[!grepl("uncl.", trait_cl)])),
     right = F, main = paste0("#" , length(unique(trait_cl))-1, " LTCs"), xlab = "LTC size")
WGCNA::plotDendroAndColors(trait_hc_filt, trait_cl_col,
                           dendroLabels = FALSE, hang = 0.03,
                           addGuide = TRUE, guideHang = 0.05,
                           main = "Gene dendrogram and module colors")



### parse results

## mark modules with ITs
check_cl <- as.matrix(table(trait_cl, colnames(fun_profi_filt) %in% ITs_mapping_filt$col_lab[!is.na(ITs_mapping_filt$trait)]))
check_cl = check_cl[!grepl("uncl.", row.names(check_cl)), ] # avoid marking 'uncl.'
trait_cl[trait_cl %in% row.names(check_cl)[check_cl[, "TRUE"] > 0]] <- paste0(trait_cl[trait_cl %in% row.names(check_cl)[check_cl[, "TRUE"] > 0]], "*")

LTC_table <- cbind(ITs_mapping_filt, 
                   data.frame(LTC=trait_cl, 
                              LTC_size=as.integer(table(trait_cl))[match(trait_cl, names(table(trait_cl)))], 
                              LTC_col=trait_cl_col))







##### Create Genome Functional Clusters (GFCs) ------------------------------------------------------

pairFUN <- function(mydata, fun.xy, ncore, similarity=T, val_index=1) {
  # if function ('fun.xy') generates a vector with multiple output values, specify the index ('val_index') of the desired one 
  
  smpl_comb <- as.matrix(combn(x = 1:ncol(mydata), m = 2))
  
  library(future.apply)
  plan(multiprocess, workers = ncore)
  comb_out <- future_apply(X = smpl_comb, MARGIN = 2, FUN = function(z) 
    fun.xy(mydata[, z[1]], mydata[, z[2]])[[val_index]] )
  
  comb_mat <- matrix(NA, nrow = ncol(mydata), ncol = ncol(mydata))
  comb_mat[lower.tri(comb_mat, diag = F)] <- comb_out
  comb_mat <- as.matrix(as.dist(comb_mat))
  if (similarity) diag(comb_mat) = 1
  dimnames(comb_mat) <- list(colnames(mydata), colnames(mydata))
  return(comb_mat)
}


### calculate genome pairwise phi-correlation
gnm_dist <- pairFUN(t(fun_profi), fun.xy = function(x, y) { 
  1-sjstats::phi(table(factor(x, levels=c(0,1)), factor(y, levels=c(0,1)))) }, ncore = 7)



### run affinity propagation
library(apcluster)

# #!!! code to check fitting of parameter "q"
# x = seq(from=0, to=0.95, length=100)
# y = future_sapply(x, function(i) {
#   length(apcluster(s = 1-gnm_dist, details=F, q=i, 
#                    lam=0.5, seed=1234, maxits=1000, convits=200)@clusters)
# })
# plot(x,y, xlab="Q-vaules", ylab="# GFCs")
# #---
apcl_res <- apcluster(s = 1-gnm_dist, details=T, q=0.5, lam=0.5, seed=1234, maxits=1000, convits=500)

## get hclust object from apcluster
gnm_hc_tmp <- 1 - as.matrix(cophenetic(as.dendrogram(aggExCluster(s = 1-gnm_dist, x = apcl_res))))
gnm_hc_tmp2 <- gnm_hc_tmp[match(row.names(fun_profi), row.names(gnm_hc_tmp)), 
                          match(row.names(fun_profi), colnames(gnm_hc_tmp))]
gnm_hc <- as.hclust(aggExCluster(s = gnm_hc_tmp2))
gnm_hc = reorder(gnm_hc, wts = colSums(fun_profi), agglo.FUN = "mean") # improve dendro sorting
gnm_hc$order = as.integer(gnm_hc$order) # otherwise it rises an issue when plotting with iheatmapr

# heatmap(apcl_res, gnm_dist); # plot(apcl_res, fun_profi); 
gnm_cl_tmp <- do.call(rbind, lapply(1:length(apcl_res@clusters), function(i) data.frame(i, apcl_res@clusters[[i]])))
gnm_cl <- gnm_cl_tmp$i[order(gnm_cl_tmp$apcl_res.clusters..i.., decreasing = F)]
gnm_cl[gnm_cl == 0] <- "uncl."
table(gnm_cl)



### parse results
GFC_table <- data.frame(gnm=row.names(fun_profi), GFC=gnm_cl)






